\documentclass{manual}

% Links
\newcommand{\mailinglist}{\ulink{mailing list}
  {mailto:pyqwt-users@lists.sourceforge.net}}
\newcommand{\Qwt}{\ulink{Qwt}
  {http://qwt.sourceforge.net}}
\newcommand{\Grace}{\ulink{Grace}
  {http://plasma-gate.weizmann.ac.il/Grace/}}
\newcommand{\target}{5.1.0}

% Source code
\newcommand{\Download}{\ulink{download}
  {http://pyqwt.sourceforge.net/download.html}}
\newcommand{\Sip}{\ulink{sip-4.7.6.tar.gz}
  {http://pyqwt.sourceforge.net/support/sip-4.7.6.tar.gz}}
\newcommand{\PyQtGpl}{\ulink{PyQt-x11-gpl-3.17.4.tar.gz}
  {http://pyqwt.sourceforge.net/support/PyQt-x11-gpl-3.17.4.tar.gz}}
\newcommand{\PyQtMac}{\ulink{PyQt-mac-gpl-3.17.4.tar.gz}
  {http://pyqwt.sourceforge.net/support/PyQt-mac-gpl-3.17.4.tar.gz}}
\newcommand{\PyQtFourGpl}{\ulink{PyQt-x11-gpl-4.4.2.tar.gz}
  {http://pyqwt.sourceforge.net/support/PyQt-x11-gpl-4.4.2.tar.gz}}
\newcommand{\PyQtFourMac}{\ulink{PyQt-mac-gpl-4.4.2.tar.gz}
  {http://pyqwt.sourceforge.net/support/PyQt-mac-gpl-4.4.2.tar.gz}}
\newcommand{\NumPy}{\ulink{NumPy}
  {http://numpy.scipy.org}}
\newcommand{\NumPyTarGz}{\ulink{NumPy-1.1.0.tar.gz}
  {http://prdownloads.sourceforge.net/numpy/numpy-1.1.0.tar.gz?download}}
\newcommand{\numarray}{\ulink{numarray}
  {http://www.stsci.edu/resources/software_hardware/numarray}}
\newcommand{\numarrayTarGz}{\ulink{numarray-1.5.2.tar.gz}
  {http://prdownloads.sourceforge.net/numpy/numarray-1.5.2.tar.gz?download}}
\newcommand{\Numeric}{\ulink{Numeric}
  {http://www.numpy.org}}
\newcommand{\NumericTarGz}{\ulink{Numeric-24.2.tar.gz}
  {http://prdownloads.sourceforge.net/numpy/Numeric-24.2.tar.gz?download}}
\newcommand{\PyQwtTarGz}{\ulink{PyQwt-\target.tar.gz}
  {http://prdownloads.sourceforge.net/pyqwt/PyQwt-\target.tar.gz?download}}
\newcommand{\PyQwtLatestTarGz}{\ulink{PyQwt-5.0.1.tar.gz}
  {http://prdownloads.sourceforge.net/pyqwt/PyQwt-5.0.1.tar.gz?download}}

\newcommand{\PythonExe}{\ulink{python-2.5.2.msi}
  {http://www.python.org/ftp/python/2.5/python-2.5.2.msi}}
\newcommand{\NumPyExe}{\ulink{numpy-1.1.0-win32-superpack-python2.5.exe}
  {http://prdownloads.sourceforge.net/numpy/numpy-1.1.0-win32-superpack-python2.5.exe}}
\newcommand{\QtExe}{\ulink{qt-win-opensource-4.4.0-mingw.exe}
  {ftp://ftp.trolltech.com/qt/source/qt-win-opensource-4.4.0-mingw.exe}}
\newcommand{\DevCpp}{\ulink{Dev-C++}
  {http://prdownloads.sourceforge.net/dev-cpp/devcpp-4.9.9.2_setup.exe}}
\newcommand{\PyQtExe}{\ulink{PyQt-Py2.5-gpl-4.4.2-1.exe}
  {http://pyqwt.sourceforge.net/support/PyQt-Py2.5-gpl-4.4.2-1.exe}}
\newcommand{\PyQwtExe}{\ulink{PyQwt5.1.0-Python2.5-PyQt4.4.2-NumPy1.1.0-1.exe}
  {http://prdownloads.sourceforge.net/pyqwt/PyQwt5.1.0-Python2.5-PyQt4.4.2-NumPy1.1.0-1.exe}}


\newcommand{\PrerequisitesEnd}{
  The source package \PyQwtTarGz{} contains a subversion snapshot of the
  \Qwt-5.1 bug fix branch which may fix some bugs in \Qwt-5.1.0.
  However, \Qwt-5.0.0, \Qwt-5.0.1, and \Qwt-5.0.2 are also supported.
  I recommend to compile and link the bug fix branch statically into PyQwt.

  To exploit the full power of PyQwt, you should install at least one of
  the numerical Python extensions:  \NumPy{}, \numarray{}, or \Numeric{}
  and built PyQwt with support for the numerical Python extension(s) of
  your choice.

  PyQwt-\target{} and recent versions of the numerical Python extensions support
  the \ulink{N-D array interface}{http://numpy.scipy.org/array_interface.shtml}
  protocol.  Therefore, PyQwt supports those extensions, even if they have not
  been installed when PyQwt has been built. However, the functionality is
  somewhat reduced in this case, since conversion from an QImage to a Numerical
  Python array is not supported.

  I am testing PyQwt with \NumPyTarGz{}, \numarrayTarGz{}, and \NumericTarGz{}.
  \NumPy{} is actively developed and recommended;
  \numarray{} and \Numeric{} are deprecated.
}

\newcommand{\Future}{
  \begin{notice}[warning]
    The documentation is for PyQwt-5.1.0 which has not yet been released. The
    latest release is \PyQwtLatestTarGz{} and refer to the documentation
    included in the latest release when using it.
  \end{notice}
}

\renewcommand{\Future}{}

\newcommand{\Blurb}{
PyQwt is a set of Python bindings for the \Qwt{} C++ class library which
extends the Qt framework with widgets for scientific, engineering and financial
applications.   It provides a widget to plot 2-dimensional data and various
widgets to display and control bounded or unbounded floating point values.

The main features of PyQwt are:
\begin{itemize}
\item
  it really shines with the Numerical Python extension \NumPy{}.
  \NumPy{} extends Python with multi-dimensional array types to turn Python
  into an ideal system for numerical computing and experimentation, better than 
  for instance MatLab and IDL. 

\item
  it requires and extends PyQt, a set of Python bindings for Qt.

\item
  it supports the use of PyQt, Qt, Qwt, \NumPy{} (\numarray{} and \Numeric{}
  are deprecated) and optionally SciPy in a GUI Python application or in an
  interactive Python session. 

\item
  it runs on POSIX, Mac OS X and Windows (any operating system supported by Qt
  and Python).
\end{itemize}
}


\title{PyQwt-5.1 Manual}

% boilerplate.tex?
\author{Gerard Vermeulen}

\date{\today}
\release{\target}
\setshortversion{\target}

\makeindex

\begin{document}

\maketitle

% This makes the contents more accessible from the front page of the HTML.
\ifhtml
\chapter*{Front Matter \label{front}}
\fi


\input{copyright}
\begin{abstract}
\noindent
\Blurb{}
\end{abstract}


\tableofcontents


\chapter{Introduction \label{introduction}}

\Future{}

PyQwt is a set of Python bindings for the \Qwt{} library featuring fast
plotting of Python lists and tuples and the powerful array types provided
by the Python extension modules \NumPy{}, \numarray{}, and \Numeric{}.

 
\section{Qwt \label{qwt-intro}}

\Future{}

Qwt is a C++ library based on the Qt GUI framework from Troll Tech AS.
The Qwt library contains widgets and components useful to write technical,
scientific, and financial programs.
It includes the following widgets:
\begin{itemize}
  \item
    \class{QwtCompass}: a very fancy QDial-like widget to display and
    control a direction.
  \item
    \class{QwtCounter}: a QSpinBox-like widget to display and control
    a bounded floating point value.
  \item
    \class{QwtDial}: a QDial-like widget to display and control a
    floating point value.
  \item
    \class{QwtKnob}: a potentiometer-like widget to display and control
    a bounded floating point value.
  \item
    \class{QwtPlot}: a widget to plot two-dimensional data points.
  \item
    \class{QwtSlider}: a QSlider-like widget to display and control a
    bounded floating point value.
  \item
    \class{QwtThermo}: a thermometer-like widget to display a floating
    point value. 
  \item
    \class{QwtWheel}: a wheel-like widget with its axis parallel to
    the computer screen to control a floating point value over a very
    large range in very small steps.
\end{itemize}
The widgets are documented in the \Qwt{} manual.

\begin{notice}[note]
  The designer plugins of the \Qwt{} library for Qt-3.x.x and Qt-4.x.x work
  with PyQwt.
  If you did built PyQwt against its internal bugfix subversion snapshot of
  \Qwt{}, you must install either the original or the internal \Qwt{} library.
\end{notice}


\section{The Python Numerical Extension modules \label{numeric-intro}}

\Future{}

The \NumPy{}, \numarray{}, and \Numeric{} modules extend Python with
multi-dimensional array types and a complete set of 'standard' functions
and operators to manipulate the arrays.

Python together with at least one of those modules is an ideal language
experimental numerical and scientific computing (as powerful as APL, MatLab,
IDL and others, but much more elegant).

If you do not have a mathematical background, you can think of those array
types as columns in a spreadsheet.  The spreadsheet lets you do operations
on whole columns at once.  Look at the following simple example:

\verbatiminput{numpy.example}

The function call \samp{arange(0.0, 10.0, 3.0)} returns a NumPy array of 4
equidistant points from 0 to 9 inclusive: \samp{array([ 0., 3., 6., 9.])}.
The function call \samp{sin(x)} and statement \samp{x*x} show that
\samp{sin} and \samp{*} manipulate NumPy arrays element by element.
All this in C, for a manifold speedup with respect to pure Python.


\section{PyQwt
  \label{pyqwt-intro}}

\Future{}

The PyQwt widgets can be used in Graphical User Interface (GUI)
programs as well as from the Command Line Interface (CLI).
This section addresses:
\begin{itemize}
\item
  the CLI facilities (iqt, qwt.qplt),
\item
  the functions to convert \class{QImage} instances to Numeric and numarray
  arrays and vice versa.
\end{itemize}

The documentation for writing GUI programs consists of the \Qwt{} manual,
supplemented by chapter \ref{reference} to document the differences between
PyQwt and Qwt.


\subsection{Command line interface
  \label{cli-intro}}

\Future{}

\begin{notice}[note]
  PyQt-4.3 and later has most of the functionality of the \module{iqt}
  module.
\end{notice}

The programming style \emph{imposed} by PyQt (before version 4.3) and other
GUI toolkit wrappers is to create an application instance with some widgets
and to enter an event loop that locks you from the Python command line
interpreter.

The \module{iqt} module enables you to:
\begin{itemize}
\item
  create and control (Py)Qt widgets from the command line interpreter or an
  enhanced interpreter like \ulink{ipython}{http://ipython.scipy.org}.
\item
  to interact with those widgets through (Py)Qt's GUI.
\end{itemize}

When Python has the GNU \module{readline} module, the \module{iqt} module
works by hooking \cfunction{qApp->processEvents()} on the event hook of the
\module{readline} module. The GNU readline library closes the event loop by
calling  \cfunction{qApp->processEvent()} at a maximum rate of 10 times per
second while reading your keyboard input.

When Python does not have the GNU \module{readline} module, the \module{iqt}
module uses the
{\ulink{techniques}
  {http://www.riverbankcomputing.com/pipermail/pyqt/2007-July/016512.html}}
suggested on the PyQt mailing list.

To see how the \module{iqt} works, play with \file{ICompass.py} by running
\begin{verbatim}
python -i ICompass.py
\end{verbatim}
or
\begin{verbatim}
python ICompass.py
\end{verbatim}
or
\begin{verbatim}
ipython ICompass.py
\end{verbatim}

My \file{.pythonrc.py} file (a symbolic link to
\file{/usr/lib/python2.5/site-packages/PyQt4/Qwt5/pythonrc.py})
tries to import the modules \module{numpy} and
\module{scipy}.
Then, it tries to import everything from the modules \module{PyQt4.Qt},
\module{PyQt4.Qwt5}, and \module{PyQt4.Qwt5.qplt} before creating an
QApplication instance.
Finally, it configures \module{readline} for tab-completion and history saving
and cleans up the global namespace:
\verbatiminput{../../qt4lib/PyQt4/Qwt5/pythonrc.py}


\subsection{Qwt5.qplt or PyQt4.Qwt5.qplt \label{qwt-qplt}}

\Future{}

The module \module{qplt} defines a tiny data-directed programming
language to simplify the use of \class{QwtPlot} from the Python command
line interpreter.
The following small example works with the \file{.pythonrc.py} file in section
\ref{cli-intro}: 

\verbatiminput{qplt.example}

\subsubsection{Qwt5.qplt.Plot or PyQt4.Qwt5.qplt.Plot \label{intro-qplt-plot}}

\Future{}

\begin{classdesc}{Plot}{*arguments}
  \class{Plot} takes any number of optional arguments.
  The data-directed interpretation of each optional argument is:
  \begin{itemize}
  \item
    \class{Axis}, to enable and redefine an axis.
  \item
    \class{Curve}, to add a curve to the plot.
  \item
    \class{QString} or a \class{string}, to set the title of the plot.
  \item
    \class{int}, to attach a set of mouse events to the zoomer actions.
  \item
    (\class{int}, \class{int}), to set the size of the plot.
  \end{itemize}

  \class{Plot} has an infinite deep stack of zoom regions. You can:
  \begin{itemize}
    \item
      select a zoom region
    \item
      unzoom all
    \item
      walk down the stack
    \item
      walk up the stack.
  \end{itemize}

  \class{Plot} uses \method{__getattr__()} to inherit all methods of
  \class{QwtPlot}.
\end{classdesc}

In addition, the class \class{Plot} defines the following methods:

\begin{methoddesc}[Plot]{clearZoomStack}{self}
Force autoscaling and clear the zoom stack.
\end{methoddesc}

\begin{methoddesc}[Plot]{formatCoordinates}{self, x, y}
Format mouse coordinates as real world plot coordinates.
\end{methoddesc}

\begin{methoddesc}[Plot]{getZoomerMouseEventSet}{self}
Return the index of the set of mouse events attached to the QwtPlotZoomer
actions.
\end{methoddesc}

\begin{methoddesc}[Plot]{gracePlot}{self, saveall="", pause=0.2}
Clone the plot into \Grace{} for very high quality hard copy output.

When \var{saveall} is not equal to \code{""}, the plot is saved to a file
named by the variable \var{saveall}.
The \Grace{} process gets killed after saving the plot.
 
Know bug: Grace does not scale the data correctly when Grace cannot
cannot keep up with gracePlot.  This happens when it takes too long
to load Grace in memory (exit the Grace process and try again) or
when 'pause' is too short.
\end{methoddesc}

\begin{methoddesc}[Plot]{plot}{self, *curves}
Plot a list of curves.
\end{methoddesc}

\begin{methoddesc}[Plot]{plotAxis}{self, orientation, options, title}
Plot and enables an axis.
\end{methoddesc}

\begin{methoddesc}[Plot]{plotCurve}{self, curve}
Plot a single curve.
\end{methoddesc}

\begin{methoddesc}[Plot]{setZoomerMouseEventSet}{self, index}
Attach the QwtPlotZoomer actions to set of mouse events.
\end{methoddesc}

\begin{methoddesc}[Plot]{toggleCurve}{self, key}
Toggle a curve between hidden and shown.
\end{methoddesc}

\subsubsection{Qwt5.qplt.IPlot or PyQt4.Qwt5.qplt.IPlot \label{intro-qplt-iplot}}

\Future{}

\begin{classdesc}{IPlot}{*arguments}
  \class{IPlot} is a main window with a Plot widget as central widget.

  The data-directed interpretation of each optional argument is the
  same as for \class{Plot}:
  \begin{itemize}
  \item
    \class{Axis}, to enable and redefine an axis.
  \item
    \class{Curve}, to add a curve to the plot.
  \item
    \class{QString} or a \class{string}, to set the title of the plot.
  \item
    \class{int}, to attach a set of mouse events to the zoomer actions.
  \item
    (\class{int}, \class{int}), to set the size of the plot.
  \end{itemize}

  The functionality of \class{Plot} is enhanced with a tool bar with
  buttons for printing and cloning into \Grace{} and a combo box to attach
  the zoomer actions to a set of mouse events.
  In addition, the position of the cursor in the plot region is tracked
  and displayed in a status bar. 

  \class{IPlot} uses \method{__getattr__()} to inherit all methods of
  \class{IPlot}.


In addition, the class \class{IPlot} defines the following methods:

\begin{methoddesc}[Plot]{onMouseMoved}{self, event}
Translate the mouse coordinates to plot coordinates for display in the status
bar.
\end{methoddesc}

\begin{methoddesc}[IPlot]{printPlot}{self}
Initialize a high resolution printer (if possible) for color output to file and
print the plot.
\end{methoddesc}

\end{classdesc}

\subsubsection{Qwt5.qplt.Curve or PyQt4.Qwt5.qplt.Curve \label{intro-qplt-curve}}

\Future{}

\begin{classdesc}{Curve}{x, y, *arguments}
  \class{Curve} takes two obligatory arguments followed by any number of
  optional arguments. The arguments \var{x} and \var{y} must be sequences
  of \class{float} objects.
  The data-directed interpretation of each optional argument is:
  \begin{itemize}
  \item
    \class{QwtPlot.Axis}, to attach an axis to the curve.  Predefined
    instances of \class{QwtPlot.Axis} are \constant{yLeft}, \constant{yRight},
    \constant{xBottom} and \constant{xTop} or \constant{Y1}, \constant{Y2},
    \constant{X1} and \constant{X2}.
  \item
    \class{Pen}, to select a pen to connect the data points.
  \item
    \class{Symbol}, to select a symbol to the data points.
  \item
    \class{string} or \class{QString}, to set the title of the curve.
  \end{itemize}
\end{classdesc}

\subsubsection{Qwt5.qplt.Axis or PyQt4.Qwt5.qplt.Axis \label{intro-qplt-axis}}

\Future{}

\begin{classdesc}{Axis}{*arguments}
  \class{Axis} takes any number of optional arguments.
  The data-directed interpretation of each optional argument is:
  \begin{itemize}
  \item
    \class{QwtPlot.Axis}, to set the orientation of the axis.  Predefined
    instances of \class{QwtPlot.Axis} are \constant{yLeft}, \constant{yRight},
    \constant{xBottom} and \constant{xTop} or \constant{Y1}, \constant{Y2},
    \constant{X1} and \constant{X2}.
  \item
    \class{QwtScaleEngine}, to set the axis type. Predefined instances of
    \class{QwtScaleEngine} are \class{QwtLinearScaleEngine} and
    \class{QwtLog10ScaleEngine} or \class{Lin} and \class{Log}.
  \item
    \class{int}, to set the attributes.
  \item
    \class{string} or \class{QString}, to set the title of the axis.
  \end{itemize}
\end{classdesc}

\subsubsection{Qwt5.qplt.Pen or PyQt4.Qwt5.qplt.Pen \label{intro-qplt-pen}}

\Future{}

\begin{classdesc}{Pen}{*arguments}
  \class{Pen} takes any number of optional arguments.
  The data-directed interpretation of each optional argument is:
  \begin{itemize}
  \item
    \class{Qt.PenStyle}, to set the style of the pen.
  \item
    \class{QColor} or \class{Qt.GlobalColor}, to set the color of the pen.
  \item
    \class{int}, to set the width of the pen.
  \end{itemize}
\end{classdesc}

\subsubsection{Qwt5.qplt.Symbol or PyQt4.Qwt5.qplt.Symbol \label{intro-qplt-symbol}}

\Future{}

\begin{classdesc}{Symbol}{*arguments}
  \class{Symbol} takes any number of optional arguments.
  The data-directed interpretation of each optional argument is:
  \begin{itemize}
  \item
    \class{QColor} or \class{Qt.GlobalColor}, to set the fill color of the
    symbol. 
  \item
    \class{QwtSymbol.Style}, to set the style of the symbol. Predefined
    instances of \class{SymbolStyle} are \constant{NoSymbol},
    \constant{Circle}, \constant{Square} and \constant{Diamond}.
  \item
    \class{int}, to set the size of the symbol.
  \end{itemize}
\end{classdesc}



\chapter{Installation
  \label{installation}}


\section{Prerequisites
  \label{prerequisites}}

\Future{}

Build prerequisites for \PyQwtTarGz{}:
\begin{enumerate}
  \item
    \ulink{Python}{http://www.python.org}.\\
    Supported versions: Python-2.5.x, Python-2.4.x.
  \item
    \ulink{Qt}{http://www.trolltech.com}.\\
    Supported versions: Qt-4.4.x, Qt-4.3.x, Qt-4.2.x, Qt-3.3.x, and Qt-3.2.x.
  \item
    \Sip{}.\\
    Supported versions: sip-4.7.x, and sip-4.6.x.
  \item
    Either \PyQtGpl{}, or \PyQtMac{}, or \PyQtFourGpl{}, or \PyQtFourMac{}.\\
    Supported versions: PyQt-4.4.x, PyQt-4.3.x, PyQt-4.2.x, and PyQt-3.17.x.
\end{enumerate}

\PrerequisitesEnd{}


\section{Unpack, configure, build, and install
  \label{install}}

\Future{}

\begin{enumerate}
\item
  Unpack \PyQwtTarGz{}.
\item
  Invoke the commands to build PyQwt-\target{} for Qt-4:
\begin{verbatim}
cd PyQwt-5.1.0
cd configure
python configure.py -Q ../qwt-5.1
make
make install
\end{verbatim}
  This assumes that the correct Python interpreter is on your path. Replace
  \strong{make} by \strong{nmake}, if you use MSVC or MSVC.net.
  The commands build PyQwt against the included Qwt subversion snapshot and
  install PyQwt.
  Test the installation by playing with the example programs.
\item
  Invoke the commands to build PyQwt-\target{} for Qt-3:
\begin{verbatim}
cd PyQwt-5.1.0
cd configure
python configure.py -3 -Q ../qwt-5.1
make
make install
\end{verbatim}
\end{enumerate}

See the last note below for all configuration options. 

\begin{notice}[note]
If you run into problems, create two log files
\begin{verbatim}
python configure.py --your --options > configure.log
make > make.log
\end{verbatim}
and send the log files to the \mailinglist{}.
\end{notice}

\begin{notice}[note]
  Check if all development packages have been installed when make produces
  lots of errors on Linux.
\end{notice}

\begin{notice}[note]
  The configure.py script takes many options. The command
\begin{verbatim}
python configure.py -h
\end{verbatim}
  displays a full list of the available options:
  \verbatiminput{configure.help}
\end{notice}


\section{Binary Installer for Windows
  \label{windows}}

\Future{}

Make sure to install
\begin{enumerate}
  \item \PythonExe{},
  \item \NumPyExe{},
  \item \PyQtExe{},
\end{enumerate}
before installing \PyQwtExe{}. 


\chapter{PyQwt Module Reference
  \label{reference}}

\Future{}

The reference should be used in conjunction with the
Qwt manual on your hard disk or \Qwt{} on the web.
Only the differences specific to the Python bindings are documented here.

In this chapter, \emph{is not yet implemented} implies that the feature can
be easily implemented if needed, \emph{is not implemented} implies that the
feature is not easily implemented, and \emph{is not Pythonic} implies that
the feature will not be implemented because it violates the Python philosophy
(e.g. may use dangling pointers).

If a class is described as being \emph{fully implemented} then all non-private
member functions and all public class variables have been implemented.

Undocumented classes have not yet been implemented or are still experimental.


\section{Function reference\label{functions}}

\Future{}

\begin{funcdesc}{toImage}{array}
  Convert \var{array} to a QImage, where \var{array} must be a two-dimensional
  NumPy, numarray, or Numeric array of type UnsignedInt8 or UnsignedInt32.
\end{funcdesc}

\begin{funcdesc}{toNumarray}{image}
  Convert \var{image} of type \class{QImage} to a numarray array. This function
  is only present if numarray has been detected when building PyQwt.
\end{funcdesc}

\begin{funcdesc}{toNumeric}{image}
  Convert \var{image} of type \class{QImage} to a Numeric array. This function
  is only present if Numeric has been detected when building PyQwt.
\end{funcdesc}

\begin{funcdesc}{toNumpy}{image}
  Convert \var{image} of type \class{QImage} to a NumPy array. This function
  is only present if NumPy has been detected when building PyQwt.
\end{funcdesc}

\begin{funcdesc}{to_na_array}{image}
  Convert \var{image} of type \class{QImage} to a Numarray array. This function
  has been deprecated and is only present if Numarray has been detected when
  building PyQwt.  Use \function{toNumarray(aQImage)}.
\end{funcdesc}

\begin{funcdesc}{to_np_array}{image}
  Convert \var{image} of type \class{QImage} to a Numeric array. This function
  has been deprecated and is is only present if Numeric has been detected when
  building PyQwt. Use \function{toNumpy(aQImage)}
\end{funcdesc}



\section{Wrappers for \ctype{QwtArray<T>} \label{qwtarray}}

\Future{}

PyQwt has a partial interface to the following C++ QwtArray templates:
\begin{enumerate}
\item
  \class{QwtArrayDouble} for \ctype{QwtArray<double>}
\item
  \class{QwtArrayInt} for \ctype{QwtArray<int>}
\item
  \class{QwtArrayQwtDoubleInterval} for \ctype{QwtArray<QwtDoubleInterval>}
\item
  \class{QwtArrayQwtDoublePoint} for \ctype{QwtArray<QwtDoublePoint>} when
  PyQwt has been built against PyQt3 or for \ctype{QwtArray<QPointF>} when
  PyQwt has been built against PyQt4.
\end{enumerate}

Those classes have at least 3 constructors -- taking QwtArrayDouble as an
example:
\begin{enumerate}
\item
  \code{array = QwtArrayDouble()}
\item
  \code{array = QwtArrayDouble(int)}
\item
  \code{array = QwtArrayDouble(otherArray)}
\end{enumerate}

QwtArrayDouble and QwtArrayInt have also a constructor which takes a
sequence of items convertable to a C++ double and a C++ long:
\begin{itemize}
\item
  \code{array = QwtArrayDouble(Numeric.array([0.0, 1.0]))}
\item
  \code{array = QwtArrayInt(Numeric.array([0, 1]))}
\end{itemize}

All those classes have 16 member functions -- taking QwtArrayDouble as example:
\begin{enumerate}
\item
  \code{array = array.assign(otherArray)}
\item
  \code{item = array.at(index)}
\item
  \code{index = array.bsearch(item)}
\item
  \code{index = contains(item)}
\item
  \code{array = otherArray.copy()}
\item
  \code{result = array.count()}
\item
  \code{array.detach()}
\item
  \code{array = array.duplicate(otherArray)}
\item
  \code{bool = array.fill(item, index=-1)}
\item
  \code{index = array.find(item, index=0)}
\item
  \code{bool = array.isEmpty()}
\item
  \code{bool = array.isNull()}
\item
  \code{bool = array.resize(index)}
\item
  \code{result = array.size()}
\item
  \code{array.sort()}
\item
  \code{bool = array.truncate(index)}
\end{enumerate}

Iterators are not yet implemented. However, the implementation of the
Python slots \function{__getitem__}, \function{__len__} and
\function{__setitem__} let you use those classes almost as a sequence.
For instance:

\verbatiminput{QwtArrayDoubleExample.txt}


\section{Class reference \label{classes}}

\Future{}


\begin{classdesc*}{QwtAbstractScale}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtAbstractScaleDraw}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtAbstractSlider}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtAlphaColorMap}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtAnalogClock}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtArrayData}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtArrayDouble}
  is a wrapper for \ctype{QwtArray<double>}, see \ref{qwtarray}.
\end{classdesc*}

\begin{classdesc*}{QwtArrayInt}
  is a wrapper for \ctype{QwtArray<int>}, see \ref{qwtarray}.
\end{classdesc*}

\begin{classdesc*}{QwtArrayQwtDoubleInterval}
  is a wrapper for \ctype{QwtArray<QwtArrayDoubleInterval>}, see \ref{qwtarray}.
\end{classdesc*}

\begin{classdesc*}{QwtArrayQwtDoublePoint}
  is a wrapper for \ctype{QwtArray<QwtArrayDoublePoint>}, see \ref{qwtarray}.
\end{classdesc*}

\begin{classdesc*}{QwtArrowButton}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtClipper}
  is fully implemented, but only available when PyQwt has been built for
  Qwt-5.1.x.
\end{classdesc*}

\begin{classdesc*}{QwtColorMap}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtCompass}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtCompassMagnetNeedle}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtCompassRose}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtCompassWindArrow}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtCounter}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtCurveFitter}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtData}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtDial}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtDialNeedle}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtDialScaleDraw}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtDialSimpleNeedle}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtDoubleInterval}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtDoublePoint}
  is fully implemented, but only available when PyQwt has been built for Qt-3.
  When PyQwt has been built for Qt-4, replace this class with \class{QPointF}
  except for in signals.
  For example, clicking in the canvas of the plot displayed canvas by the
  following program
  \begin{verbatim}
#!/usr/bin/env python

import sys
from PyQt4 import Qt
import PyQt4.Qwt5 as Qwt

def aSlot(aQPointF):
    print 'aSlot gets:', aQPointF

# aSlot()

def make():
    demo = Qwt.QwtPlot()
    picker = Qwt.QwtPlotPicker(Qwt.QwtPlot.xBottom,
                               Qwt.QwtPlot.yLeft,
                               Qwt.QwtPicker.PointSelection,
                               Qwt.QwtPlotPicker.CrossRubberBand,
                               Qwt.QwtPicker.AlwaysOn,
                               demo.canvas())
    picker.connect(picker, Qt.SIGNAL('selected(const QwtDoublePoint&)'), aSlot)
    return demo

# make()

def main(args):
    app = Qt.QApplication(args)
    demo = make()
    demo.show()
    sys.exit(app.exec_())

# main()

if __name__ == '__main__':
    main(sys.argv)

# Local Variables: ***
# mode: python ***
# End: ***
  \end{verbatim}
  shows that the signal return on object of type QPointF:
  \begin{verbatim}
aSlot gets: <PyQt4.QtCore.QPointF object at 0x2aaaaf73be20>
  \end{verbatim}
\end{classdesc*}

\begin{classdesc*}{QwtDoubleRange}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtDoubleRect}
  is fully implemented, but only available when PyQwt has been built for Qt-3.
  When PyQwt has been built for Qt-4, replace this class with \class{QRectF}
  except for in signals. See \class{QwtDoublePoint}.
\end{classdesc*}

\begin{classdesc*}{QwtDoubleSize}
  is fully implemented, but only available when PyQwt has been built for Qt-3.
  When PyQwt has been built for Qt-4, replace this class with \class{QSizeF}
  except for in signals. See \class{QwtDoublePoint}.
\end{classdesc*}

\begin{classdesc*}{QwtDynGridLayout}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtEventPattern}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtIntervalData}
  is fully implemented.
  
  \begin{cfuncdesc}{}{QwtIntervalData}{
      const QwtArray<QwtDoubleInterval> \&intervals,
      const QwtArray<double> \&values}
    is implemented as
    \begin{verbatim}
intervalData = QwtIntervalData(intervals, values)
    \end{verbatim}
    where intervals is a QwtArrayQwtDoubleInterval or a list containing
    QwtDoubleInterval instances.
  \end{cfuncdesc}

  \begin{cfuncdesc}{void}{setData}{
      const QwtArray<QwtDoubleInterval> \&intervals,
      const QwtArray<double> \&values}
    is implemented as
    \begin{verbatim}
intervalData.setData(intervals, values)
    \end{verbatim}
    where intervals is a QwtArrayQwtDoubleInterval or a list containing
    QwtDoubleInterval instances.
  \end{cfuncdesc}

\end{classdesc*}

\begin{classdesc*}{QwtKnob}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtLegend}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtLegendItem}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtLegendItemManager}
  is fully implemented, but only available when PyQwt has been built for
  Qwt-5.1.x. 
\end{classdesc*}

\begin{classdesc*}{QwtLinearColorMap}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtLinearScaleEngine}
is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtLog10ScaleEngine}
is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtLegendMagnifier}
  is fully implemented, but only available when PyQwt has been built for
  Qwt-5.1.x. 
\end{classdesc*}

\begin{classdesc*}{QwtMetricsMap}
is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPaintBuffer}
  is fully implemented.
  This class does not exist when PyQwt has been built for Qt-4.
\end{classdesc*}

\begin{classdesc*}{QwtPainter}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPanner}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPicker}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPickerClickPointMachine}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPickerClickRectMachine}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPickerDragPointMachine}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPickerDragRectMachine}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPickerMachine}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPickerPolygonMachine}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlainTextEngine}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlot}

  \begin{cfuncdesc}{void}{print}{
      QPrinter \&printer, const QwtPlotPrintFilter \&filter}
    is implemented as
    \begin{verbatim}
plot.print_(printer, filter)
    \end{verbatim}
  \end{cfuncdesc}

  \begin{cfuncdesc}{void}{print}{
      QPainter *painter,
      const QRect \&rect,
      const QwtPlotPrintFilter \&filter}
    is implemented as
    \begin{verbatim}
plot.print_(painter, rect, filter)
    \end{verbatim}
  \end{cfuncdesc}

\end{classdesc*}

\begin{classdesc*}{QwtPlotCanvas}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlotCurve}

  \begin{cfuncdesc}{void}{setData}{double *x, double *y, int size}
    is implemented as
    \begin{verbatim}
curve.setData(x, y)
    \end{verbatim}
    where \var{x} and \var{y} can be any combination of lists, tuples and
    Numerical Python arrays.  The data is copied to C++ data types.
  \end{cfuncdesc}

  \begin{cfuncdesc}{void}{setRawData}{double *x, double *y, int size}
      is not Pythonic.
  \end{cfuncdesc}

\end{classdesc*}

\begin{classdesc*}{QwtPlotDict}
  is fully implemented.
  FIXME: is the auto delete feature dangerous?
\end{classdesc*}

\begin{classdesc*}{QwtPlotGrid}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlotItem}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlotLayout}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlotMagnifier}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlotMarker}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlotPanner}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlotPicker}
  is fully implemented.

  \begin{cfuncdesc}{QwtText}{trackerText}{QwtDoublePoint \&point}
    is implemented as
    \begin{verbatim}
qwtText = plotPicker.trackerTextF(point)
    \end{verbatim}
    where \var{point} is a QwtDoublePoint when PyQwt has been built for Qt-3 or
    a QPointF when PyQwt has been built for Qt-4.
  \end{cfuncdesc}

\end{classdesc*}

\begin{classdesc*}{QwtPlotPrintFilter}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlotRasterItem}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlotScaleItem}
  is fully implemented, but only available when PyQwt has been built for
  Qwt-5.1.x. 
\end{classdesc*}

\begin{classdesc*}{QwtPlotSpectrogram}
  FIXME: protected methods.
\end{classdesc*}

\begin{classdesc*}{QwtPlotSvgItem}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPlotZoomer}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtPolygon}
  When PyQwt has been built for Qt-3, replace this class with
  \class{QPointArray} except for in signals. See \class{QwtDoublePoint}.

  When PyQwt has been built for Qt-4, replace this class with \class{QPolygon}
  except for in signals. See \class{QwtDoublePoint}.
\end{classdesc*}

\begin{classdesc*}{QwtPolygonFData}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtRasterData}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtRect}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtRichTextEngine}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtRoundScaleDraw}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtScaleArithmic}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtScaleDiv}

  \begin{cfuncdesc}{}
    {QwtScaleDiv}{
      const QwtDoubleInterval\&,
      QwtValueList[NTickList]}
    is implemented as
    \begin{verbatim}
scaleDiv = QwtScaleDiv(qwtDoubleInterval, majorTicks, mediumTicks, minorTicks)
    \end{verbatim}
  \end{cfuncdesc}

  \begin{cfuncdesc}{}
    {QwtScaleDiv}{
      double,
      double,
      QwtTickList[NTickList]}
    is implemented as
    \begin{verbatim}
scaleDiv = QwtScaleDiv(lower, upper, majorTicks, mediumTicks, minorTicks)
    \end{verbatim}
  \end{cfuncdesc}

\end{classdesc*}

\begin{classdesc*}{QwtScaleDraw}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtScaleEngine}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtScaleMap}
  is fully implemented.

  \begin{cfuncdesc}{}
    {QwtScaleMap}{
      int,
      int,
      double,
      double}
    does not exist in C++, but is provided by PyQwt. 
  \end{cfuncdesc}
\end{classdesc*}

\begin{classdesc*}{QwtScaleTransformation}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtScaleWidget}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtSimpleCompassRose}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtSlider}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtSpline}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtSplineCurveFitter}
  is fully implemented.
\end{classdesc*}
 
\begin{classdesc*}{QwtSymbol}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtText}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtTextEngine}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtTextLabel}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtThermo}
  is fully implemented.
\end{classdesc*}

\begin{classdesc*}{QwtWheel}
  is fully implemented.
\end{classdesc*}

\input{pyqwt.ind}

\end{document}

%% Local Variables:
%% fill-column: 79
%% End: